<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>超级华容道</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #1a202c;
            --device-base: #2c5282;
            --screen-bg: #0f1218;
            --neon-blue: #00fff2;
        }

        body {
            background-color: var(--bg-color);
            background-image: 
                radial-gradient(rgba(255,255,255,0.1) 1px, transparent 1px),
                radial-gradient(rgba(255,255,255,0.05) 1px, transparent 1px);
            background-size: 20px 20px, 10px 10px;
            background-position: 0 0, 10px 10px;
            color: white;
            font-family: 'Segoe UI', system-ui, sans-serif;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }

        /* 游戏机主体 */
        .device-body {
            width: 95vw;
            max-width: 420px;
            background: linear-gradient(165deg, #4299e1 0%, #2b6cb0 60%, #1a365d 100%);
            border-radius: 2rem;
            padding: 1.5rem;
            box-shadow: 
                0 25px 50px -12px rgba(0, 0, 0, 0.7),
                inset 0 2px 4px rgba(255,255,255,0.3),
                inset 0 -4px 6px rgba(0,0,0,0.3);
            position: relative;
            border: 2px solid #3182ce;
        }

        /* 屏幕区域 */
        .screen-panel {
            background: var(--screen-bg);
            border-radius: 1rem;
            padding: 1rem;
            margin-bottom: 1.5rem;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.8);
            border: 4px solid #1a202c;
            position: relative;
        }

        /* 数据显示 */
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            margin-bottom: 1rem;
            font-family: 'Orbitron', monospace;
        }
        .status-item { text-align: right; }
        .status-label { font-size: 0.7rem; color: #718096; display: block; margin-bottom: 2px; }
        .status-value { font-size: 1.5rem; color: var(--neon-blue); text-shadow: 0 0 8px rgba(0, 255, 242, 0.4); line-height: 1; }

        /* 棋盘容器 */
        .board-container {
            width: 100%;
            padding-bottom: 125%; /* Aspect Ratio 4:5 */
            position: relative;
            background: #0d131a;
            border-radius: 0.5rem;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.8);
        }

        /* 棋盘层 */
        .game-board {
            position: absolute;
            top: 6px; left: 6px; right: 6px; bottom: 6px;
        }

        /* 出口 */
        .exit-gate {
            position: absolute;
            bottom: -8px; left: 25%; width: 50%; height: 8px;
            background: #48bb78;
            border-radius: 0 0 8px 8px;
            box-shadow: 0 0 10px #48bb78;
            z-index: 1;
        }

        /* 棋子 */
        .block {
            position: absolute;
            background: #e2e8f0;
            border-radius: 6px;
            box-sizing: border-box;
            transition: transform 0.15s cubic-bezier(0.4, 0.0, 0.2, 1);
            z-index: 10;
            cursor: pointer;
            box-shadow: 
                inset 0 1px 0 rgba(255,255,255,0.4),
                inset 0 -2px 0 rgba(0,0,0,0.2),
                0 2px 5px rgba(0,0,0,0.5);
            
            /* 确保父容器相对定位，方便Logo绝对定位 */
            /* 移除 Flex 居中，改用绝对定位方案 */
            display: block; 
        }
        .block:active { transform: scale(0.96) !important; filter: brightness(0.9); transition: none; }
        .block::after {
            content: ''; position: absolute;
            top: 4px; left: 4px; right: 4px; bottom: 4px;
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 4px;
            pointer-events: none;
        }

        /* 棋子类型样式 */
        .type-cao { background: linear-gradient(145deg, #e53e3e, #9b2c2c); border: 1px solid #822727; }
        .type-guan { background: linear-gradient(145deg, #48bb78, #2f855a); border: 1px solid #276749; }
        .type-zhang { background: linear-gradient(145deg, #4299e1, #2b6cb0); border: 1px solid #2a4365; }
        .type-bing { background: linear-gradient(145deg, #ecc94b, #b7791f); border: 1px solid #975a16; }

        /* Logo 样式 - 强制视觉居中修正 */
        .kk-logo {
            position: absolute;
            top: 50%;
            left: 50%;
            /* -55% Y轴是为了修正 Orbitron 字体视觉重心偏下的问题 */
            transform: translate(-50%, -55%);
            
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            color: rgba(255,255,255,0.3);
            font-size: clamp(2rem, 10vw, 4rem);
            line-height: 1;
            white-space: nowrap;
            pointer-events: none;
            user-select: none;
        }

        /* 控制区 */
        .controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.8rem;
            margin-top: 1.5rem;
        }

        .btn {
            background: linear-gradient(180deg, #4a5568 0%, #2d3748 100%);
            border: none;
            border-radius: 0.8rem;
            padding: 0.8rem 0;
            color: #e2e8f0;
            font-weight: bold;
            font-size: 0.9rem;
            box-shadow: 0 4px 0 #1a202c;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: all 0.1s;
        }
        .btn:active { transform: translateY(3px); box-shadow: 0 1px 0 #1a202c; }
        .btn-hint {
            background: linear-gradient(180deg, #d69e2e 0%, #b7791f 100%);
            color: #fff;
            grid-column: span 3;
            margin-top: 0.5rem;
            position: relative;
            overflow: hidden;
        }
        .btn-hint.thinking::after {
            content: "AI 计算中...";
            position: absolute; inset: 0;
            background: rgba(0,0,0,0.7);
            display: flex; align-items: center; justify-content: center;
            font-size: 0.9rem;
        }

        /* Win Modal */
        .modal-overlay {
            position: absolute; inset: 0;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(4px);
            z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            opacity: 0; pointer-events: none;
            transition: opacity 0.3s;
            border-radius: 2rem;
        }
        .modal-overlay.active { opacity: 1; pointer-events: all; }
    </style>
</head>
<body>

<div class="device-body">
    <div style="text-align: center; color: #a0aec0; font-size: 0.8rem; margin-bottom: 0.5rem; letter-spacing: 1px; font-weight: bold;" id="level-name">
        Loading...
    </div>

    <div class="screen-panel">
        <div class="status-bar">
            <div class="status-item" style="text-align: left;">
                <span class="status-label">LEVEL</span>
                <span class="status-value" id="disp-level">1</span>
            </div>
            <div class="status-item">
                <span class="status-label">BEST</span>
                <span class="status-value" style="color:#68d391;">--</span>
            </div>
            <div class="status-item">
                <span class="status-label">STEPS</span>
                <span class="status-value" id="disp-steps">0</span>
            </div>
        </div>

        <div class="board-container">
            <div class="game-board" id="board">
                <!-- Blocks generated by JS -->
            </div>
            <div class="exit-gate"></div>
        </div>
    </div>

    <div class="controls">
        <button class="btn" onclick="Game.prevLevel()">
            <svg class="w-5 h-5 mb-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>
            上一关
        </button>
        <button class="btn" style="background: linear-gradient(180deg, #e53e3e 0%, #9b2c2c 100%);" onclick="Game.resetLevel()">
            <svg class="w-5 h-5 mb-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg>
            重置
        </button>
        <button class="btn" onclick="Game.nextLevel()">
            <svg class="w-5 h-5 mb-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
            下一关
        </button>
        <button class="btn btn-hint" id="btn-hint" onclick="Game.getHint()">
            <div style="display: flex; align-items: center; gap: 6px;">
                <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20"><path d="M11 3a1 1 0 10-2 0v1a1 1 0 102 0V3zM15.657 5.757a1 1 0 00-1.414-1.414l-.707.707a1 1 0 001.414 1.414l.707-.707zM18 10a1 1 0 01-1 1h-1a1 1 0 110-2h1a1 1 0 011 1zM5.05 6.464A1 1 0 106.464 5.05l-.707-.707a1 1 0 00-1.414 1.414l.707.707zM5 10a1 1 0 01-1 1H3a1 1 0 110-2h1a1 1 0 011 1zM8 16v-1h4v1a2 2 0 11-4 0zM12 14c.015-.34.208-.646.477-.859a4 4 0 10-4.954 0c.27.213.462.519.476.859h4.002z"></path></svg>
                智能提示
            </div>
        </button>
    </div>

    <div class="modal-overlay" id="win-modal">
        <h2 class="text-4xl font-black text-yellow-400 mb-2" style="font-family: 'Orbitron'">VICTORY</h2>
        <p class="text-gray-300 mb-6">Level Cleared</p>
        <button class="btn btn-hint" style="width: 60%;" onclick="Game.nextLevel()">CONTINUE</button>
    </div>
</div>

<script>
/**
 * 华容道核心逻辑与AI求解器
 */
const Game = (function() {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const ctx = new AudioContext();
    
    function playSound(type) {
        if (ctx.state === 'suspended') ctx.resume();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.connect(gain);
        gain.connect(ctx.destination);

        const now = ctx.currentTime;
        if (type === 'slide') {
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(200, now);
            osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.1);
            osc.start(now);
            osc.stop(now + 0.1);
        } else if (type === 'win') {
            osc.type = 'square';
            osc.frequency.setValueAtTime(440, now);
            osc.frequency.setValueAtTime(554, now + 0.1);
            osc.frequency.setValueAtTime(659, now + 0.2);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.6);
            osc.start(now);
            osc.stop(now + 0.6);
        }
    }

    const LAYOUTS = [
        { name: "兵临城下", grid: ["B A A C", "B A A C", "D F F E", "D J K E", "L . . M"] },
        { name: "横刀立马", grid: ["B A A C", "B A A C", "D F F E", "D K L E", "J . . M"] },
        { name: "将拥曹营", grid: ["B A A C", "B A A C", "D . . E", "D F F E", "J K L M"] },
        { name: "齐头并进", grid: ["B A A C", "B A A C", "D E F F", "D E J K", "L M . ."] },
        { name: "兵分三路", grid: ["A A B C", "A A B C", "J K L M", "D F F E", "D . . E"] },
        { name: "雨声淅沥", grid: ["B A A C", "B A A C", "J D E K", "L D E M", "F F . ."] },
        { name: "左右布兵", grid: ["B A A C", "B A A C", "J D E K", "F F G G", "L . . M"] },
        { name: "堵塞要道", grid: ["B A A C", "B A A C", "J K L M", "D E F F", "D E . ."] },
        { name: "瓮中之鳖", grid: ["B A A C", "B A A C", "D J K E", "D F F E", "L . . M"] },
        { name: "层层设防", grid: ["A A B C", "A A B C", "D F F E", "D J K E", ". L M ."] },
        { name: "水泄不通", grid: ["B A A C", "B A A C", "D E F F", "D E J K", "L . . M"] },
        { name: "四路进兵", grid: ["B A A C", "B A A C", "D J K E", "D . . E", "F F G G"] }
    ];

    let currentLevelIdx = 0;
    let blocks = []; 
    let steps = 0;
    let isSolving = false;

    const boardEl = document.getElementById('board');
    const levelNameEl = document.getElementById('level-name');
    const dispLevel = document.getElementById('disp-level');
    const dispSteps = document.getElementById('disp-steps');
    const hintBtn = document.getElementById('btn-hint');
    const winModal = document.getElementById('win-modal');

    function parseLevel(gridStrs) {
        const charMap = {};
        for(let y=0; y<5; y++) {
            const row = gridStrs[y].replace(/\s+/g, '').split(''); 
            for(let x=0; x<4; x++) {
                const char = row[x];
                if (char === '.') continue;
                if (!charMap[char]) {
                    charMap[char] = { char, x, y, cells: [] };
                }
                charMap[char].cells.push({x, y});
            }
        }

        const newBlocks = [];
        let idCounter = 0;
        
        Object.values(charMap).forEach(info => {
            const w = Math.max(...info.cells.map(c => c.x)) - Math.min(...info.cells.map(c => c.x)) + 1;
            const h = Math.max(...info.cells.map(c => c.y)) - Math.min(...info.cells.map(c => c.y)) + 1;
            let type = 'bing';
            if (w===2 && h===2) type = 'cao';
            else if (w===2 && h===1) type = 'guan';
            else if (w===1 && h===2) type = 'zhang';

            newBlocks.push({
                id: idCounter++,
                char: info.char,
                type,
                x: info.x,
                y: info.y,
                w, h
            });
        });
        return newBlocks;
    }

    function renderBlocks() {
        boardEl.innerHTML = '';
        blocks.forEach(b => {
            const el = document.createElement('div');
            el.className = `block type-${b.type}`;
            
            const wPct = b.w * 25;
            const hPct = b.h * 20;
            const gap = 4;
            
            el.style.width = `calc(${wPct}% - ${gap}px)`;
            el.style.height = `calc(${hPct}% - ${gap}px)`;
            el.style.left = `calc(${b.x * 25}% + ${gap/2}px)`;
            el.style.top = `calc(${b.y * 20}% + ${gap/2}px)`;
            
            if(b.type === 'cao') {
                el.innerHTML = '<span class="kk-logo">KK</span>';
            }

            el.onmousedown = (e) => handleInput(e, b);
            el.ontouchstart = (e) => handleInput(e, b);

            boardEl.appendChild(el);
            b.el = el;
        });
    }

    function updateBlockPos(b) {
        const gap = 4;
        b.el.style.left = `calc(${b.x * 25}% + ${gap/2}px)`;
        b.el.style.top = `calc(${b.y * 20}% + ${gap/2}px)`;
    }

    function loadLevel(idx) {
        const baseIdx = (idx - 1) % LAYOUTS.length;
        const layout = LAYOUTS[baseIdx];
        
        let grid = [...layout.grid];
        
        const cycle = Math.floor((idx - 1) / LAYOUTS.length);
        if (cycle % 2 !== 0) {
            grid = grid.map(row => {
                const cleanRow = row.replace(/\s+/g, '');
                return cleanRow.split('').reverse().join('').split('').join(' '); 
            });
        }

        blocks = parseLevel(grid);
        steps = 0;
        
        levelNameEl.innerText = `${layout.name} ${cycle > 0 ? '(Var)' : ''}`;
        dispLevel.innerText = idx;
        dispSteps.innerText = 0;
        winModal.classList.remove('active');
        
        renderBlocks();
    }

    function canMove(b, dx, dy) {
        const nx = b.x + dx;
        const ny = b.y + dy;
        
        if (nx < 0 || nx + b.w > 4 || ny < 0 || ny + b.h > 5) return false;
        
        for(let other of blocks) {
            if (other.id === b.id) continue;
            if (nx < other.x + other.w && nx + b.w > other.x &&
                ny < other.y + other.h && ny + b.h > other.y) {
                return false;
            }
        }
        return true;
    }

    function move(b, dx, dy, isAi = false) {
        if(canMove(b, dx, dy)) {
            b.x += dx;
            b.y += dy;
            updateBlockPos(b);
            if(!isAi) {
                steps++;
                dispSteps.innerText = steps;
                playSound('slide');
            }
            checkWin();
            return true;
        }
        return false;
    }

    function checkWin() {
        const cao = blocks.find(b => b.type === 'cao');
        if(cao.x === 1 && cao.y === 3) {
            playSound('win');
            setTimeout(() => {
                winModal.classList.add('active');
            }, 300);
        }
    }

    function handleInput(e, b) {
        e.preventDefault();
        const startX = e.touches ? e.touches[0].clientX : e.clientX;
        const startY = e.touches ? e.touches[0].clientY : e.clientY;
        
        const moveHandler = (ev) => {
            const currX = ev.touches ? ev.touches[0].clientX : ev.clientX;
            const currY = ev.touches ? ev.touches[0].clientY : ev.clientY;
            const dx = currX - startX;
            const dy = currY - startY;
            
            if(Math.abs(dx) > 30 || Math.abs(dy) > 30) {
                cleanup();
                if(Math.abs(dx) > Math.abs(dy)) {
                    move(b, Math.sign(dx), 0);
                } else {
                    move(b, 0, Math.sign(dy));
                }
            }
        };

        const cleanup = () => {
            document.removeEventListener('mousemove', moveHandler);
            document.removeEventListener('mouseup', cleanup);
            document.removeEventListener('touchmove', moveHandler);
            document.removeEventListener('touchend', cleanup);
        };

        document.addEventListener('mousemove', moveHandler);
        document.addEventListener('mouseup', cleanup);
        document.addEventListener('touchmove', moveHandler, { passive: false });
        document.addEventListener('touchend', cleanup);
    }

    function getSignature(blks) {
        const groups = { 'cao':[], 'guan':[], 'zhang':[], 'bing':[] };
        blks.forEach(b => groups[b.type].push((b.y<<2) | b.x));
        
        groups['guan'].sort((a,b)=>a-b);
        groups['zhang'].sort((a,b)=>a-b);
        groups['bing'].sort((a,b)=>a-b);
        
        return `${groups.cao[0]}|${groups.guan.join('')}|${groups.zhang.join('')}|${groups.bing.join('')}`;
    }

    function solve() {
        if(isSolving) return;
        hintBtn.classList.add('thinking');
        isSolving = true;

        setTimeout(() => {
            const startState = blocks.map(b => ({...b}));
            const caoId = blocks.find(b => b.type === 'cao').id;

            const queue = [];
            queue.push({ blks: startState, path: [] });
            
            const visited = new Set();
            visited.add(getSignature(startState));

            let foundPath = null;
            let iterations = 0;
            const MAX_ITER = 40000;

            while(queue.length > 0) {
                iterations++;
                if(iterations > MAX_ITER) break;

                const curr = queue.shift();
                
                const currCao = curr.blks.find(b => b.id === caoId);
                if(currCao.x === 1 && currCao.y === 3) {
                    foundPath = curr.path;
                    break;
                }

                const grid = new Array(20).fill(null);
                curr.blks.forEach(b => {
                    for(let i=0; i<b.h; i++) 
                        for(let j=0; j<b.w; j++) 
                            grid[(b.y+i)*4 + (b.x+j)] = b.id;
                });
                
                for(let b of curr.blks) {
                    const moves = [{dx:0, dy:-1}, {dx:0, dy:1}, {dx:-1, dy:0}, {dx:1, dy:0}];
                    for(let m of moves) {
                        const nx = b.x + m.dx;
                        const ny = b.y + m.dy;
                        
                        if (nx < 0 || nx + b.w > 4 || ny < 0 || ny + b.h > 5) continue;

                        let blocked = false;
                        for(let i=0; i<b.h; i++) {
                            for(let j=0; j<b.w; j++) {
                                const targetIdx = (ny+i)*4 + (nx+j);
                                const occupier = grid[targetIdx];
                                if (occupier !== null && occupier !== b.id) {
                                    blocked = true;
                                    break;
                                }
                            }
                            if(blocked) break;
                        }

                        if(!blocked) {
                            const nextBlks = curr.blks.map(ob => ob.id === b.id ? {...ob, x:nx, y:ny} : ob);
                            const sig = getSignature(nextBlks);
                            
                            if(!visited.has(sig)) {
                                visited.add(sig);
                                const newPath = curr.path.length === 0 ? [{id:b.id, dx:m.dx, dy:m.dy}] : curr.path;
                                queue.push({ blks: nextBlks, path: newPath });
                            }
                        }
                    }
                }
            }

            hintBtn.classList.remove('thinking');
            isSolving = false;

            if(foundPath && foundPath.length > 0) {
                const step = foundPath[0];
                const targetBlock = blocks.find(b => b.id === step.id);
                move(targetBlock, step.dx, step.dy, true);
                playSound('slide');
            } else {
                alert("未找到解法，或者步数太长超出搜索范围。");
            }

        }, 50);
    }

    return {
        init: () => loadLevel(1),
        nextLevel: () => { currentLevelIdx++; loadLevel(currentLevelIdx + 1); },
        prevLevel: () => { if(currentLevelIdx>0) currentLevelIdx--; loadLevel(currentLevelIdx + 1); },
        resetLevel: () => loadLevel(currentLevelIdx + 1),
        getHint: solve
    };
})();

Game.init();

</script>
</body>
</html>